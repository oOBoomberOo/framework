const fs = require('fs');
const path = require('path');
const del = require('del');
const vanilla = require('./vanilla');
const { item_handler, create_file } = require('./furniture/item');

async function main(furniture_file, output) {
	// await del(output);
	const furniture_list = JSON.parse(fs.readFileSync(furniture_file));
	const framework = path.join(output, `loot_tables/framework`);
	const item = path.join(framework, `item`);
	const furniture_table = path.join(framework, `trait/furniture_table`);
	const functions = path.join(output, `functions/framework/trait`);
	const item_frame_block = path.join(functions, `item_frame_block`);
	const meta = { output, framework, item, furniture_table, functions, item_frame_block };

	const promises = [];
	for (const kind of furniture_list) {
		const { trait } = kind;
		if (trait !== 'vanilla') {
			const promise = furniture(meta, kind);
			promises.push(promise);
		}
		else {
			const promise = vanilla(meta, kind);
			promises.push(promise);
		}
	}

	const item_list = await Promise.all(promises);

	await create_file(path.join(item_frame_block, 'auto_trait.mcfunction'), [
		`#> This function is generated by generator`,
		...item_list.map(v => v.auto_trait).flat().filter(v => v)
	]);
	await create_file(path.join(furniture_table, `furniture_list.json`), {
		type: "minecraft:item",
		pools: item_list.map(v => v.furniture_list).flat().filter(v => v)
	});

	const group_trait = {};
	item_list.filter(({ trait }) => trait !== 'vanilla').forEach(({ trait, list }) => {
		if (!group_trait[trait]) {
			group_trait[trait] = list;
		}
		else {
			group_trait[trait].push(...list);
		}
	});

	for (const trait in group_trait) {
		const list = group_trait[trait];
		create_file(path.join(functions, trait, 'remove.mcfunction'), [
			`#> This function is generated by generator`,
			...list.map(({ name }) => `execute if entity @s[tag=boomber.framework.block.${trait}.${name}] run loot spawn ~ ~ ~ loot boomber:framework/item/${trait}/${name}`),
			`kill @s`
		]);
	}
}

async function furniture(meta, kind) {
	const { furniture_table, framework } = meta;
	const { trait, block_model, item_model = block_model, offset = 0, list, step = 1, expandable = false, initial, item = 'minecraft:structure_void' } = kind;
	const target_trait = expandable && initial ? `${trait}.${initial}`: trait;

	const promises = [];
	for (let index = 0; index < list.length; index++) {
		const item = list[index];
		const model_offset = (index + offset) * step;
		const model = { item_model: item_model + index + offset, block_model: block_model + model_offset };
		const promise = item_handler(item, {...meta, kind, target_trait, model, model_offset});
		promises.push(promise);
	}

	const item_list = await Promise.all(promises);

	create_file(path.join(framework, 'trait', `${trait}.json`), {
		"type": "minecraft:item",
		"pools": [
			{
				"rolls": 1,
				"entries": [
					{
						"type": "minecraft:item",
						"name": item,
						"functions": [
							{
								"function": "minecraft:set_nbt",
								"tag": `{CustomModelData: ${block_model}, ucit: {id: "${trait}", from: "boomber:framework"}}`
							}
						]
					}
				]
			}
		]
	});

	if (expandable) {
		
		create_file(path.join(furniture_table, 'furniture', `${target_trait}.json`), furniture_trait(item_model + offset, target_trait));
		create_file(path.join(furniture_table, 'expand', `${target_trait}.json`), {
				type: "minecraft:item",
				pools: [	
					{
						"rolls": 1,
						"entries":[ 
							{
								"type": "minecraft:loot_table",
								"name": "boomber:framework/trait/furniture_table/expand/back"
							}
						]
					},
					...item_list.map(v => v.furniture_list)]
		});

		return {
			auto_trait: item_list.map(v => v.auto_trait),
			furniture_list: {
				rolls: 1,
				entries: [
					{
						type: "minecraft:loot_table",
						name: `boomber:framework/trait/furniture_table/furniture/${target_trait}`
					}
				]
			},
			trait,
			list
		};
	}
	else {
		return {
			auto_trait: item_list.map(v => v.auto_trait),
			furniture_list: item_list.map(v => v.furniture_list),
			trait,
			list
		}
	}
}

function furniture_trait(model, target_trait) {
	let result = furniture_template('minecraft:item_frame');
	let functions = result.pools[0].entries[0].functions;
	functions.push({
		function: "minecraft:set_nbt",
		tag: `{CustomModelData: ${model},ucit: {framework: {expand: 'boomber:framework/trait/furniture_table/expand/${target_trait}'}, id: 'furniture_expandable', from: 'boomber:framework', group: ['furniture_table/ui', 'furniture_table/selection']}}`
	});
	functions.push({
		function: "minecraft:set_name",
		name: {"translate": `boomber.framework.trait.${target_trait}`, "italic": false}
	});

	return result;
}

function furniture_template(item) {
	return {
		"type": "minecraft:item",
		"pools": [
			{
				"rolls": 1,
				"entries": [
					{
						"type": "minecraft:item",
						"name": item,
						"functions": []
					}
				]
			}
		]
	}
}

module.exports = main;