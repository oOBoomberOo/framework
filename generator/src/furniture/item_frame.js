const mkdirp = require('mkdirp');
const fs = require('fs');
const path = require('path');
const { promisify } = require('util');

async function main(item, meta) {
	const { kind: { trait }, item_frame_block } = meta;
	const { name } = item;
	await create_file(path.join(item_frame_block, 'block', trait, name, 'run.mcfunction'), run(item, meta));
	await create_file(path.join(item_frame_block, 'block', trait, name, 'fail.mcfunction'), fail(item, meta));
	await create_file(path.join(item_frame_block, 'block', trait, name, 'success.mcfunction'), success(item, meta));
	await create_file(path.join(item_frame_block, 'block', trait, name, 'template_builder.mcfunction'), template(item, meta));
}

function run(item, meta) {
	const { kind: { trait, lookup } } = meta;
	const { name } = item;

	if (lookup) {
		const { target } = lookup;
		if (lookup.name === 'behind_or_current') {
			return [
				`#> This function is generated by generator`,
				`execute positioned ^ ^ ^-1 if block ~ ~ ~ ${target} if entity @e[tag=boomber.framework.trait.${trait}, distance=..0.3] run function boomber:framework/trait/item_frame_block/block/${trait}/${name}/fail`,
				`execute positioned ^ ^ ^-1 if block ~ ~ ~ ${target} unless entity @e[tag=boomber.framework.trait.${trait}, distance=..0.3] run function boomber:framework/trait/item_frame_block/block/${trait}/${name}/success`,
				`execute unless block ^ ^ ^-1 ${target} if entity @e[tag=boomber.framework.trait.${trait}, distance=..0.3] run function boomber:framework/trait/item_frame_block/block/${trait}/${name}/fail`,
				`execute unless block ^ ^ ^-1 ${target} unless entity @e[tag=boomber.framework.trait.${trait}, distance=..0.3] run function boomber:framework/trait/item_frame_block/block/${trait}/${name}/success`,
			];
		}
		else if (lookup.name === 'behind') {
			return [
				`#> This function is generated by generator`,
				`execute unless block ^ ^ ^-1 ${target} run function boomber:framework/trait/item_frame_block/block/${trait}/${name}/fail`,
				`execute positioned ^ ^ ^-1 if block ~ ~ ~ ${target} if entity @e[tag=boomber.framework.trait.${trait}, distance=..0.3] run function boomber:framework/trait/item_frame_block/block/${trait}/${name}/fail`,
				`execute positioned ^ ^ ^-1 if block ~ ~ ~ ${target} unless entity @e[tag=boomber.framework.trait.${trait}, distance=..0.3] run function boomber:framework/trait/item_frame_block/block/${trait}/${name}/success`,
			];
		}
		else if (lookup.name === 'behind_no_checking') {
			return [
				`#> This function is generated by generator`,
				`execute positioned ^ ^ ^-1 if entity @e[tag=boomber.framework.trait.${trait}, distance=..0.3] run function boomber:framework/trait/item_frame_block/block/${trait}/${name}/fail`,
				`execute positioned ^ ^ ^-1 unless entity @e[tag=boomber.framework.trait.${trait}, distance=..0.3] run function boomber:framework/trait/item_frame_block/block/${trait}/${name}/success`,
			];
		}
	}
	return [
		`#> This function is generated by generator`,
		`execute if entity @e[tag=boomber.framework.trait.${trait}, distance=..0.3] run function boomber:framework/trait/item_frame_block/block/${trait}/${name}/fail`,
		`execute unless entity @e[tag=boomber.framework.trait.${trait}, distance=..0.3] run function boomber:framework/trait/item_frame_block/block/${trait}/${name}/success`
	];
}

function fail(item, meta) {
	const { name } = item;
	const { kind: { trait } } = meta;
	return [
		`#> This function is generated by generator`,
		`loot spawn ~ ~ ~ loot boomber:framework/item/${trait}/${name}`,
		`kill @s`
	];
}

function success(item, meta) {
	const { name } = item;
	const { kind: { trait }, model_offset = 0 } = meta;
	return [
		`#> This function is generated by generator`,
		`scoreboard players set #bb.fw.model_offset bb.variable ${model_offset}`,
		`function boomber:framework/trait/entity/template/armor_stand`,
		`execute as @e[type=minecraft:armor_stand, tag=boomber.framework.template] run function boomber:framework/trait/item_frame_block/block/${trait}/${name}/template_builder`,
		`kill @s`
	];
}

function template(item, meta) {
	const { name } = item;
	const { kind: { trait, extra_traits = [] } } = meta;
	return [
		`#> This function is generated by generator`,
		`tag @s add boomber.framework.block.${trait}.${name}`,
		`function boomber:framework/trait/block/implement`,
		...extra_traits.map(trait => `function boomber:framework/trait/${trait}/implement`),
		`function boomber:framework/trait/${trait}/implement`,
		`function boomber:framework/trait/entity/template/finalize`
	];
}

const write = promisify(fs.writeFile);

async function create_file(file, data) {
	const parent = path.join(file, '..');
	mkdirp.sync(parent);
	let compiled_data = data;

	if (Array.isArray(data)) {
		compiled_data = data.join('\n');
	}
	else if (typeof data === 'object') {
		compiled_data = JSON.stringify(data, null, '\t');
	}
	return await write(file, compiled_data);
}

module.exports = main;